/*
 * $Id: cgi.ici,v 1.4 2002/09/18 02:18:48 atrn Exp $
 *
 * ICI module to interface with the HTTP server Common Gateway Interface
 */

/*
 * content_type - generate a "Content-type" HTTP header
 *
 * Parameters:
 *	type		The MIME type to output, a string.
 */
extern
content_type(type)
{
    printf("Content-type: %s\r\n", type);
}

/*
 * content_length - generate a "Content-Length" HTTP header
 *
 * Parameters:
 *	length		The number of bytes of output, an integer.
 */
extern
content_length(length)
{
    printf("Content-Length: %d\r\n", length);
}

/*
 * start_reply_header - start the CGI program's output
 *
 * Parameters:
 *	key, value...	Pairs of strings defining HTTP reply
 *			header field names and their values.
 *
 *			Note that the common HTTP header fields
 *			have their own functions (see below).
 *
 */
extern
start_reply_header()
{
    auto	vargs = [array];
    auto	i, n;

    if ((n = nels(vargs)) & 1)
	fail("uneven # of args to start_reply_header");
    for (i = 0; i < n; i += 2)
	printf("%s: %s\r\n", vargs[i], vargs[i+1]);
}

/*
 * end_reply_header - output the end of header line (a blank line)
 */
extern
end_reply_header()
{
    printf("\r\n");
}

/*
 * status - generate a status CGI header
 *
 * Parameters:
 *      code
 *      msg
 */
extern
status(code, msg)
{
    printf("Status: %d", code);
    if (msg)
        printf(" %s", msg);
    printf("\r\n");
}

extern
no_content()
{
    return status(204, "No Content");
}

/*
 * redirect - generate a redirect message
 *
 * Parameters:
 *	url		The URL where the user should be taken.
 */
extern
redirect(status, url)
{
    auto status_desc = [struct
	(301) = "Moved permanently",
	(302) = "Moved temporaily",
    ];
    if (url == NULL)
    {
        url = status;
	status = 302;
    }
    if (!(msg = status_desc[status]))
	msg = "Redirect";
    printf
    (
	"Status: %d %s\r\n"
	"Location: %s\r\n",
	status,
	msg,
	url
    );
    content_type("text/plain");
    end_reply_header();
    printf("Redirecting to %s\n", url);
}

/*
 * setcookie - output an HTTP header for setting the cookie.
 */
extern
setcookie(text)
{
    printf("Set-cookie: \r\n", text);
}

/*
 * getcookie - return the cookie for this request or NULL if no cookie.
 */
extern
getcookie()
{
    return getenv("HTTP_COOKIE");
}

/*
 * string_to_urle - convert a string to "URL encoding" and return it
 *
 * Parameters:
 *	s	unencoded string
 *
 * Returns:
 *	The encoded string.
 */
extern
string_to_urle(s)
{
    /* This variable is initialised at parse-time */
    auto	plain = $([func ()
		{
		    auto rc, c, C;

		    rc = set();
		    for (c = 'a', C = 'A'; c <= 'z'; ++c, ++C)
		    {
			rc[tochar(c)] = 1;
			rc[tochar(C)] = 1;
		    }
		    for (c = '0'; c <= '9'; ++c)
		        rc[tochar(c)] = 1;
		    return rc;
		}]());

    auto rc, c;

    rc = array();
    forall (c in s)
    {
	if (plain[c])
	    push(rc, c);
	else
	    push(rc, sprintf("%%%02x", toint(c)));
    }
    return implode(rc);
}

/*
 * urle_to-string - remove URL encoding sequences from a string and return it
 *
 * Parameters:
 *	s	URL-encoded string
 */
extern
urle_to_string(s)
{
    static hex = [struct
	("0") = 0,	("1") = 1,	("2") = 2,	("3") = 3,
	("4") = 4,	("5") = 5,	("6") = 6,	("7") = 7,
	("8") = 8,	("9") = 9,	("a") = 10,	("A") = 10,
	("b") = 11,	("B") = 11,	("c") = 12,	("C") = 12,
	("d") = 13,	("D") = 13,	("e") = 14,	("E") = 14,
	("f") = 15,	("F") = 15
    ];

    auto a;
    s = gsub(s, #\+#, " ");
    while (nels(a = s ~~~ #^([^%]*)%([0-9A-Fa-f])([0-9A-Fa-f])(.*)$#) == 4)
	s = sprintf("%s%c%s", a[0], hex[a[1]] * 16 + hex[a[2]], a[3]);
    return s;
}

/*
 * query_string_to_struct - parse query string into key/value pairs, make a
 *			    struct out of them and return it.
 *
 * Parameters:
 *	qs	Optional alternative string to parse. If not passed query
 *		string is ripped out of the environment or from standard
 *		input according to the HTTP method used (GET or POST).
 */
extern
query_string_to_struct(qs)
{
    static r, f, qs = NULL, method;

    /*
     * If no explicit query string passed to us then get it. Where we
     * get it from depends on the HTTP method used.
     */
    if (!qs)
    {
	switch (method = getenv("REQUEST_METHOD"))
	{
	case NULL:
	    fail("no query string");

	case "GET":
	    qs = getenv("QUERY_STRING");
	    break;

	case "POST":
	    if (getenv("CONTENT_TYPE") ~ #multipart/form-data#)
	    {
		return cgi.multipart_form_data();
	    }
	    qs = getfile();
	    break;

	default:
	    fail
	    (
		sprintf
		(
		    "don't know how to get query string for HTTP %s method",
		    method
		)
	    );
	}
	if (qs == "" || qs == NULL)
	    fail("no query string");
    }

    /*
     * Now split it and create a struct with all the key/values in the string
     */
    r = struct();
    forall (f in gettokens(qs, "&"))
    {
        f = f ~~~ #^(.*)=(.*)$#;
	r[urle_to_string(f[0])] = urle_to_string(f[1]);
    }
    return r;
}

/*
 * Short forms for lazy people
 */
extern query_string = query_string_to_struct;
extern query = query_string_to_struct;


/*
 * Multipart form data parser
 */

static
strip_cr(str)
{
    len = nels(str) - 1;
    if (len >= 0 && str[len] == "\r")
	str = interval(str, 0, len);
    return str;
}

static
initial_state(input, ctx)
{
    input = strip_cr(input);
    if (input ~ ctx.boundary)
    {
	ctx.hdrs = array();
	return header_state;
    }
}

static
header_state(input, ctx)
{
    input = strip_cr(input);
    if (input == "")
    {
	return body_state;
    }
    else if (input ~ $regexpi("^content-disposition:"))
    {
	if (!(v = input ~~ $regexpi("^content-disposition:(.*)")))
	    return;
	form_data := false;
	data_name := NULL;
	file_name := NULL;
	forall (t in gettokens(v, "; "))
	{
	    if (t == "form-data")
		form_data = true;
	    else if (t ~ #^name=#)
		data_name = t ~~ #^name="(.*)"#;
	    else if (t ~ #^filename=#)
		file_name = t ~~ #^filename="(.*)"#;
	}
	if (!form_data || data_name == "")
	    fail("incorrect content disposition");
	if (file_name)
	{
	    ctx.values[data_name + "_file_name"] = file_name;
	}
	if (data_name)
	{
	    ctx.values[data_name] = "";
	    ctx.curval = data_name;
	}
    }
}

static
body_state(input, ctx)
{
    input = strip_cr(input);
    if (input ~ ctx.sentinel)
    {
	fail("end");
    }
    else if (input ~ ctx.boundary)
    {
	return header_state;
    }
    if (ctx.neednl && ctx.values[ctx.curval] != "")
	ctx.values[ctx.curval] = ctx.values[ctx.curval] + "\n";
    ctx.values[ctx.curval] = ctx.values[ctx.curval] + input;
    ctx.neednl = true;
}

extern
multipart_form_data()
{
    v := gettokens(getenv("CONTENT_TYPE"), "; ");
    if (v[0] != "multipart/form-data")
	fail("Incorrectly invoked");
    if (v[1] !~ #^boundary=#)
	fail(sprintf("Unexpected input: \"%s\"", v[1]));
    boundary := v[1] ~~ #^boundary=(.*)#;
    ctx := struct();
    ctx.boundary = regexp(sprintf("--%s", boundary));
    ctx.sentinel = regexp(sprintf("%s--", boundary));
    ctx.values = struct();
    for (handler := initial_state; line := getline(); )
    {
	try
	{
	    if (next := handler(line, ctx))
		handler = next;
	}
	onerror
	{
	    if (error == "end")
		break;
	    printf(stderr, "post state machine: error = %s\n", error);
	    fail(error);
	}
    }
    return ctx.values;
}
