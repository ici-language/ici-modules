static files = struct();

extern cmd = 0;
extern stop = 0;    /* Stop on next line. */
extern bp = NULL;;
extern trace = 0;
/*
 * Depth the scope stack must return to in order for use to have
 * finished the 'next' command.
 */
extern next = 0;

extern
dbg_error(e, fname, lineno)
{
    printf("DBG: FAIL: %s, %d: %s\n", fname, lineno, e);
}

extern
summary_line(fname, lineno, vs)
{
    /*
     * Generate the stack traceback string.
     */
    bt := strbuf();
    sep := "";
    cvs := copy(vs);
    while (v := pop(cvs))
    {
        if (v._func_ != NULL)
	    s := sprintf("%a", v._func_);
        else if (v._file_ != NULL)
	    s := sprintf("%a", v._file_);
        else
            s := "?";
        strcat(bt, sep, s);
        sep := " ";
    }
    /*
     * Generate the source location string.
     */
    sl := sprintf("%s, %d", fname, lineno);
    /*
     * Generate the actual source text string.
     */
    if (files[fname] == NULL)
    {
	try
            files[fname] = gettokens(getfile(fname), '\n');
        onerror
            files[fname] = array();
    }
    lines := files[fname];
    if ((st := lines[lineno - 1]) == NULL)
        st := "?";
    st = gsub(st, #\s+#, " ");

    /*
     * -sl:15-|-st:39-|-bt:23-
     * ----------79-----------
     */
    if (nels(sl) > 15)
        sl = interval(sl, -15);
    st = interval(st, 0, 39);
    bt = interval(bt, 0, 23);
    return sprintf("%15s|%-39s|%-23s", sl, st, bt);
}

extern
dbg_src(fname, lineno)
{
    auto    vs;

    if (bp == lineno)
    {
        stop = 1;
        cmd = 1;
    }
    if (next > 0)
    {
        vs := vstack();
        pop(vs);
        if (nels(vs) <= next)
        {
            next = 0;
            stop = 1;
            cmd = 1;
        }
    }
    if (!stop && !trace)
        return;
    if (vs == NULL)
    {
        vs := vstack();
        pop(vs);
    }
    printf("%s\n", summary_line(fname, lineno, vs));
    if (cmd)
        prompt(vs);
}

extern
dbg_fncall(func, args)
{
    auto	a, i;

    if (typeof(func) == "func")
        n := func.name;
    else
        n := sprintf("%a", func);
    if (!stop && !trace)
        return;
    printf("%15s> %s(", "", n);
    forall (a, i in args)
    {
	printf("%a%s", a, i < nels(args) - 1 ? ", " : "");
    }
    printf(")\n");
}

extern
dbg_fnresult(result)
{
    if (!stop && !trace)
        return;
    printf("%15s< %a\n", "", result);
}

static text(f) {return gettoken(f, "]");}

static help = [text
c       continue execution
n       next - execute till new source line at this call depth
s       step - execute till new source line
u       until - execute till subsequent line at this call depth
t       toggle printing of tace summary lines
q       quit
p expr  evaluate expr and print result
v       print local variables
vv      print next outer scope variables
vvv...  etc.
!cmd    execute cmd in a sub-shell
];

extern
prompt(vs)
{
    for (;;)
    {
        try
        {
            printf("DBG> ");
            flush(stdout);
            l := getline();
            if (l ~ #^!#)
            {
                system(interval(l, 1));
                continue;
            }
            if (l ~ #^p #)
            {
                l = interval(l, 2);
                l = sprintf("x := (%s);", l);
                s := parse(l, struct(top(vs)));
                printf("%a\n", s.x);
                continue;
            }
            if (l ~ #^v#)
            {
                d := nels(l) - 1;
                ss := top(vs);
                while (d-- > 0 && ss != NULL)
                    ss = super(ss);
                forall (k in sort(keys(ss)))
                {
                    if (!typeof(k) == "string")
                        continue;
                    printf("%15s: %a\n", k, ss[k]);
                }
                continue;
            }
            l = smash(l, #\S+#, "\\&");
            if (l == NULL)
            {
                printf("? for help\n");
                continue;
            }
            switch (l[0])
            {
            case "?":
            case "help":
            case "h":
                printf("%s", help);
                continue;

            case "c":
                stop = 0;
                cmd = 0;
                return;

            case "s":
                stop = 1;
                return;

            case "n":
                next = nels(vs);
                stop = 0;
                cmd = 0;
                return;

            case "b":
                break_line = int(l[1]);
                continue;

            case "q":
                exit(1);

            case "t":
                trace = !trace;
                printf("trace now %s\n", trace ? "on" : "off");
                continue;

            default:
                printf("? for help\n");
                continue;
            }
        }
        onerror
        {
            printf("DBG error: %s\n", error);
        }
    }
}

trace = 1;
debug(1);
