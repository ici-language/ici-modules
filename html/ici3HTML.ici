/*
 * $Id: ici3HTML.ici,v 1.10 2002/05/23 00:29:26 atrn Exp $
 *
 *
 * HTML element classes for ICI.
 *
 *
 * Copyright (C) A.Newman, 2001.
 *
 */


/*
 * Clean a string making it suitable for output via HTML.
 * This encodes any special characters as HTML entities.
 */
static encode(s)
{
	s = gsub(s, #&#, "&amp;"); // nb. must do this first!
	s = gsub(s, #<#, "&lt;");
	s = gsub(s, #>#, "&gt;");
	return s;
}


/*
 * HTML.Element  -  base class for HTML elements
 *
 * An element is the base unit in the document hierarchy.  An element
 * has a "tag", some attributes (key/value pairs), some body text and
 * a sequence of child elements.  The basic operations on elements are
 * setting its body text, adding child elements, setting attributes and
 * finally generating an HTML representation of an element.
 *
 * The element output operation is implemented in stages.  Each stage
 * is implemented in a separate method allowing derived classes to
 * specialise the behaviour.  Output is separated into "head", "body"
 * and "tail" sections. Output of element attributes is also separated
 * out allowing separate control over attribute output if required.
 *
 * The interface to element output is a single method, "output(file)",
 * that outputs HTML for the element instance to the given file.  This
 * interface can be considered a "protocol".  Any class that implements
 * an "output(file)" method may be used as a child element within an
 * HTML.Element instance.  Presumably the class performs some special
 * action, e.g, a database lookup, and returns appropriate HTML objects
 * to present the object within the HTML page.
 *
 * Adding child elements is performed by the "add()" method. "add()"
 * appends the elements given as its arguments to the child elements
 * of the instance.  The "add()" method also allows strings, arrays
 * and functions to be passed as children to be added to the array.
 * If an array is given its elements are passed to "add()" to be added 
 * individually.  The elements may be object instances, arrays or functions
 * as per the arguments to "add()".  If a function is passed it is
 * called and its result passed in a recursive call to "add()" on
 * the instance.  The function may return an object instance, array
 * or function as per the arguments to "add()".
 *
 * The above calling semantics give great flexibliity in adding objects.
 * A single invoccation of "add()" is often sufficent to generate a
 * complete page or complex document structure and the use of embedded
 * functions simplifies the dynamic generation of content.
 *
 */
extern Element = [class


	/**
	 * element = HTML.Element:new(tag, text)
	 *
	 * Create a new instance of an element.  The arguments are the
	 * element's tag and optional body text, both strings.  The new
	 * element is created with the given tag and body text and no
	 * attributes or children.
	 */
	new(tag, text)
	{
		auto text = "";
		if (!text)
			text = "";
		this = this:^new();
		this.el_tag := tag;
		this.el_attr := struct();
		this.el_children := array();
		this.el_text := text;
		this.el_class := NULL;
		this.el_id := NULL;
		this.el_style := NULL;
		return this;
	}


	/**
	 * element = element:output([file])
	 *
	 * Output an element to the given file or stdout if no file is passed.
	 * This method outputs an HTML representation of the element instance
	 * to the given stream.  Output is performed in three method calls -
	 * "output_head()" to output the start of the element.  Then "output_body()"
	 * to output any body text and child elements and finally "output_tail()"
	 * to generate the end tag for the element.
	 *
	 * The method returns the instance to allow method chaining.
	 */
	output(file)
	{
		if (!file)
			file = stdout;

		this:output_head(file);
		this:output_body(file);
		this:output_tail(file);

		return this;
	}


	/**
	 * element:output_head(file)
	 *
	 * Output the element's start tag and attributes.
	 */
	output_head(file)
	{
		printf(file, "<%s", encode(el_tag));
		this:output_attr(file);
		printf(file, ">");
	}


	/**
	 * element:output_attr(file)
	 *
	 * Output the element's attributes for use in a HTML tag.
	 */
	output_attr(file)
	{
		auto k;
		if (el_class)
			printf(file, " class=\"%s\"", encode(el_class));
		if (el_id)
			printf(file, " id=\"%s\"", encode(el_id));
		if (el_style)
			printf(file, " style=\"%s\"", encode(el_style));
		if (nels(el_attr) > 0)
			forall (k in sort(keys(el_attr)))
				printf(file, " %s=\"%s\"", encode(k), encode(el_attr[k]));
	}


	/**
	 * element:output_body(file)
	 *
	 * Output the element's body and children to the given file.
	 */
	output_body(file)
	{
		printf(file, "%s", encode(el_text));
		auto k;
		forall (k in el_children)
		{
			t := typeof(k);
			while (t == "func" || t == "method")
				t = typeof(k = k());
			if (t == "string")
				printf(file, "%s", encode(k));
			else
				k:output(file);
		}
	}


	/**
	 * element:output_tail(file)
	 *
	 * Output the element's end tag.
	 */
	output_tail(file)
	{
		if (!file)
			file = stdout;
		printf(file, "</%s>", encode(el_tag));
	}


	/**
	 * string = element:get_text()
	 *
	 * Return the element's body text.  If the element has
	 * no body text an empty string is returned.
	 */
	get_text()
	{
		return el_text;
	}


	/**
	 * element = element:text(string)
	 *
	 * Set the element's body text to the given string.
	 * Returns the instance for method chaining.
	 */
	text(text)
	{
		el_text = text;
		return this;
	}


	/**
	 * element = element:klass(str)
	 *
	 * Define the class of an element.
	 */
	klass(str)
	{
		el_class = str;
		return this;
	}


	/**
	 * element = element:id(str)
	 *
	 * Define the id of an element.
	 */
	id(str)
	{
		el_id = str;
		return this;
	}


	/**
	 * element = element:style(str)
	 *
	 * Define a style attribute for an element.
	 */
	style(str)
	{
		el_style = str;
		return this;
	}


	/**
	 * element = element:add_text(string)
	 *
	 * Append the given string to the element's body text.
	 */
	add_text(text)
	{
		el_text += text;
		return this;
	}


	/*
	 * element = element:add(...)
	 *
	 * Add child elements to an element.  See the comment at
	 * the head of this class for a description of the arguments
	 * and semantics of this method.
	 *
	 * Returns the element instance for method chaining.
	 */
	add()
	{
		auto child, vargs = [array];
		forall (child in vargs)
		{
			if ((t := typeof(child)) == "array")
				call(this:add, child);
			else // assume struct or string
				push(el_children, child);
		}
		return this;
	}


	/**
	 * array = element:children()
	 *
	 * Return the array storing the element's children.
	 */
	children()
	{
		return el_children;
	}


	/**
	 * element = element:attr(name, value)
	 *
	 * Set the named attribute of the element to the given value.
	 * Both name and value are strings.  If the attribute exists
	 * it is overwritten, if it does not exist it is created.
	 * Returns the element instance for method chaining.
	 */
	attr(name, val)
	{
		el_attr[name] = val;
		return this;
	}


	/**
	 * string|NULL = element:get_attr(string)
	 *
	 * Return the value of the named attribute.  Returns NULL
	 * if there is no such attribute for this element.
	 */
	get_attr(name)
	{
		return el_attr[name];
	}

];


/**
 * HTML.NoEndTagElement  --  internal base-class for elements with no end tag
 *
 * This is a specialisation of HTML.Element that removes overrides output_tail()
 * so no end tag is generated for type of this element.  All other behaviour is
 * the same as HTML.Element.
 */
static NoEndTagElement = [class: Element,

	output_tail(file)
	{
	}

];


/**
 * HTML.Markup  --  class to represent arbtirary content
 *
 * The HTML.Markup class provides an escape mecahanism within
 * the structure of HTML.Element based classes.  An HTML.Markup
 * instance stores arbitrary text which is output direct to
 * the output stream.  The intent is to allow any HTML content
 * to be used with this class hierarchy.
 */
extern Markup = [class: NoEndTagElement,

	/**
	 * element = HTML.Markup:new(string)
	 *
	 * Create a new element holding the given content data
	 * given as argument.  The data is output verbatim
	 * during output.  Markup elements allow arbitrary
	 * data to be embedded within a document.
	 */
	new(text)
	{
		return this:^new(NULL, text);
	}


	/**
	 * markup:output_head(file)
	 *
	 * Override Element:output_head() to do nothing.
	 */
	output_head(file)
	{
	}


	/**
	 * markup:output_body(file)
	 *
	 * Implement Element:output_body() to output our
	 * markup content.  We can't use the Element class
	 * implementation as we define no concept of children
	 * (although we inherit it, the behaviour is nullified
	 * by not outputting any child elements).
	 */
	output_body(file)
	{
		printf(file, "%s", el_text);
	}

];


/**
 * HTML.P  --  HTML paragraph element
 *
 * An HTML.P instance represents a paragraph.  It is a special
 * case of element in that it has no start tag and the end of a
 * paragraph is marked by a sole "<P>" element.  The class
 * overrides the "output_head()" method to remove any start
 * tag and implements "output_tail()" to generate the "<p>".
 * Body output is done by HTML.Element.
 */
extern P = [class: Element,


	/**
	 * element = HTML.P:new([string])
	 *
	 * Create a new HTML paragraph element with the given string
	 * as its body.  If no argument is passed the body is the
	 * empty string.
	 */
	new(text)
	{
		return this:^new("p", text);
	}


	/**
	 * p:output_head(file)
	 *
	 * Override Element:output_head to do nothing.
	 */
	output_head(file)
	{
	}


	/**
	 * p:output_tail(file)
	 *
	 * Implement Element:output_tail() to output the
	 * trailing paragraph tag.
	 */
	output_tail(file)
	{
		printf(file, "<p>");
	}

];


/**
 * HTML.Big  --  wrapper element that displays its body text in a larger font
 */
extern Big = [class: Element,

	new(text)
	{
		return this:^new("big", text);
	}

];


/**
 * HTML.Small  --  wrapper element that displays its body text in a smaller font
 */
extern Small = [class: Element,

	new(text)
	{
		return this:^new("small", text);
	}

];


/**
 * HTML.Cite  --  wrapper element that displays its body text as a citation
 */
extern Cite = [class: Element,

	new(text)
	{
		return this:^new("cite", text);
	}

];


/**
 * HTML.Code  --  wrapper element that displays its body text as program code
 */
extern Code = [class: Element,

	new(text)
	{
		return this:^new("code", text);
	}

];


/**
 * HTML.Kbd  --  wrapper element that displays its body text as keyboard entered text
 */
extern Kbd = [class: Element,

	new(text)
	{
		return this:^new("kbd", text);
	}

];


/**
 * HTML.Strike  --  wrapper element that displays its body text in a strikeout font
 */
extern Strike = [class: Element,

	new(text)
	{
		return this:^new("strike", text);
	}

];


/**
 * HTML.Strong  --  wrapper element that displays its body text in a strong style
 */
extern Strong = [class: Element,

	new(text)
	{
		return this:^new("strong", text);
	}

];


/**
 * HTML.Typewriter  --  wrapper element that displays its body text in a fixed width font
 */
extern Typewriter = [class: Element,

	new(text)
	{
		return this:^new("tt", text);
	}

];


/**
 * HTML.Underline  -- wrapper element that displsus its body text with an underline
 */
extern Underline = [class: Element,

	new(text)
	{
		return this:^new("u", text);
	}

];


/**
 * HTML.Font  --  control font presentation
 *
 * An HTML.Font element allows control over the font
 * used by any child elements.  It is a wrapper element
 * to control the presentation of its children.
 *
 */
extern Font = [class: Element,

	/**
	 * element = HTML.Font:new([string])
	 *
	 * Create a new Font element with the given body text.
	 */
	new(text)
	{
		return this:^new("font", text);
	}


	/**
	 * element = element:face(string)
	 *
	 * Set the typeface used with a Font element.
	 * Returns the element instance to allow for method chaining.
	 */
	face(face)
	{
		return this:attr("face", face);
	}


	/**
	 * element = element:size(int|string)
	 *
	 * Set the size of the font defined by the font element.
	 * The size may be given as a integer or string.
	 * Returns the element instance to allow for method chaining.
	 */
	size(size)
	{
		return this:attr("size", string(size));
	}


	/**
	 * element = element:color(string)
	 *
	 * Set the color used when drawing characters with a
	 * font element.
	 */
	color(c)
	{
		return this:attr("color", c);
	}

];


/**
 * HTML.Bold  --  embolden child element text
 *
 */
extern Bold = [class: Element,

	/**
	 * element = HTML.Bold:new([string])
	 *
	 * Create a new Bold element with the given body text.
	 */
	new(text)
	{
		this = this:^new("b", text);
		return this;
	}

];


/**
 * HTML.Italic  --  italicise child element text
 */
extern Italic = [class: Element,

	/**
	 * element = HTML.Italic:new([string])
	 *
	 * Create a new Italic element with the given body text.
	 */
	new(text)
	{
		this = this:^new("i", text);
		return this;
	}

];


/**
 * HTML.Address  --  wrapper element that displays its body as an address
 */
extern Address = [class: Element,

	new(text)
	{
		return this:^new("address", text);
	}

];


/**
 * HTML.Em  --  wrapper element that displays its body in a emphasised style
 */
extern Em = [class: Element,

	new(text)
	{
		return this:^new("em", text);
	}

];


/**
 * HTML.Blockquote  --  wrapper element that displays its body as a quote
 */
extern Blockquote = [class: Element,

	new(text)
	{
		return this:^new("blockquote", text);
	}

];


/**
 * HTML.Page  -  a HTML page
 */
extern Page = [class: Element,


	/**
	 * page = HTML.Page:new([string [, bool]])
	 *
	 * Create a new HTML.Page instance with the given title string, if any.
	 * If the second parameter is passed it can be used to disable the
	 * default behaviour that assumes we are running as a CGI program
	 * under some HTTP server.  If the flag is passed as false no CGI
	 * output is generated.
	 */
	new(title, docgi)
	{
		auto docgi = true;
		auto title = "";
		this = this:^new("body");
		this.page_title := title;
		this.page_headers := array();
		this.page_docgi := docgi;
		this.page_cgiheaders := array();
		if (!docgi)
			this.page_param := struct();
		else
		{
			try
				this.page_param := cgi.query_string_to_struct();
			onerror
				this.page_param := struct();
		}
		return this;
	}


	/**
	 * string = page:param(string)
	 */
	param(key)
	{
		return page_param[key];
	}


	/**
	 * struct = page:params()
	 */
	params()
	{
		return page_param;
	}


	/**
	 * page = page:nocgi([flag])
	 *
	 * Disable or enable output of CGI headers.  They are enabled by default.
	 */
	nocgi(flag)
	{
		auto flag = true;
		page_docgi = !flag;
		return this;
	}

	/**
	 * page = page:title(string)
	 *
	 * Set the page title.
	 */
	title(title)
	{
		page_title = title;
		return this;
	}


	/**
	 * page = page:colors(string [, string [, string, [string]]])
	 *
	 * Define the colors used when rendering the page.  The first
	 * argument, the only required argument, defines the page background
	 * color.  The second argument is the default color of text, the
	 * third argument the default color of links and the final argument
	 * the default color of visited links.
	 */
	colors(bgcolor, text, link, vlink)
	{
		this:attr("bgcolor", bgcolor);
		if (text)
			this:attr("text", text);
		if (link)
			this:attr("link", link);
		if (vlink)
			this:attr("vlink", vlink);
		return this;
	}


	/**
	 * page = page:bgcolor(string)
	 *
	 * Define the page background color.
	 */
	bgcolor(c)
	{
		return this:attr("bgcolor", c);
	}


	/**
	 * page = page:text_colors(string [, string, [string]])
	 *
	 * Define the colors used when drawing text on the page.  The first
	 * argument is the default color of text, the second argument the
	 * color of text within anchors and the third argument the color
	 * of visited links.
	 */
	text_colors(text, link, vlink)
	{
		this:attr("text", text);
		if (link)
			this:attr("link", link);
		if (vlink)
			this:attr("vlink", vlink);
		return this;
	}


	/**
	 * page = page:add_header(element)
	 *
	 * Add an element to the header section of the page, i.e, the portion
	 * between the <head> and </head> tags.  This is used to add meta tags
	 * and the like.
	 */
	add_header(h)
	{
		push(page_headers, h);
		return this;
	}


	/**
	 * page = page:style(text)
	 */
	style(text)
	{
		this:add_header(Style:new(text));
	}


	/**
	 * page:output_head(file)
	 *
	 * Implement Element:outupt_head() to output the page header
	 * before the <body> tag, which is our element's tag in the
	 * Element instance.  This outputs the headers defined by
	 * by user.
	 */
	output_head(file)
	{
		/* If we're running as a CGI program output the header unless disabled */
		if (page_docgi && getenv("REQUEST_METHOD"))
		{
			call(cgi.start_reply_header, page_cgiheaders);
			cgi.content_type("text/html");
			cgi.end_reply_header();
		}
		printf
		(
			file,
			"<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\">"
			"<html><head><title>%s</title>"
			"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=US-ASCII\">",
			page_title
		);
		auto s;
		forall (h in page_headers)
			h:output(file);
		printf(file, "</head>");
		this:^output_head(file);
	}


	/**
	 * page = page:add_cgi_header(name, value)
	 */
	add_cgi_header(nom, val)
	{
		push(page_cgiheaders, nom);
		push(page_cgiheaders, val);
		return this;
	}


	/**
	 * page:output_tail(file)
	 *
	 * Implement Element:output_tail() to output the real
	 * end of page tag following the </body> our superclass
	 * outputs.
	 */
	output_tail(file)
	{
		this:^output_tail(file);
		printf(file, "</html>\n");
	}

];


/**
 * HTML.Style  --  page header style element
 */
extern Style = [class: Element,

	new(text)
	{
		return this:^new("style", text);
	}

];


/**
 * HTML.Hr  -  a horizontal rule, i.e, line
 */
extern Hr = [class: NoEndTagElement,

	new(size, shade)
	{
		auto shade = true;
		this = this:^new("hr");
		if (size != NULL && size != 0)
			this:attr("size", string(size));
		this.hr_noshade := !shade;
		return this;
	}

	shade(flag)
	{
		auto flag = false;
		hr_noshade = !flag;
		return this;
	}

	noshade(flag)
	{
		auto flag = true;
		return this:shade(!flag);
	}

	size(size)
	{
		return this:attr("size", string(size));
	}

	output_attr(file)
	{
		if (hr_noshade)
			printf(file, " noshade");
		this:^output_attr(file);
	}

];


/**
 * HTML.Image  --  an embedded image element
 */
extern Image = [class: NoEndTagElement,

	new(src, alt)
	{
		auto alt = "[Image]";
		this = this:^new("img");
		this.i_ismap := false;
		this:src(src);
		this:alt(alt);
		return this;
	}

	output_attr(file)
	{
		if (i_ismap)
			printf(file, " ismap");
		this:^output_attr(file);
	}

	src(url)
	{
		return this:attr("src", url);
	}
	
	alt(txt)
	{
		return this:attr("alt", txt);
	}

	align(a)
	{
		return this:attr("align", a);
	}

	border(n)
	{
		return this:attr("border", string(n));
	}

	width(w)
	{
		return this:attr("width", string(w));
	}
	
	height(h)
	{
		return this:attr("height", string(h));
	}

	ismap(flag)
	{
		auto flag = true;
		i_ismap = flag;
		return this;
	}

	usemap(map)
	{
		return this:attr("usemap", map);
	}

];


/**
 * HTML.Br  --  a forced line break
 */
extern Br = [class: NoEndTagElement,

	new()
	{
		return this:^new("br");
	}

];


/**
 * HTML.Hx  --  internal base class for header elements.
 */
static Hx = [class: Element,

	new(n, header)
	{
		return this:^new(sprintf("h%d", n), header);
	}

];


/**
 * HTML.H1  -- level 1 header.
 */
extern H1 = [class: Hx,

	new(header)
	{
		return this:^new(1, header);
	}

];


/**
 * HTML.H2  -- level 2 header.
 */
extern H2 = [class: Hx,

	new(header)
	{
		return this:^new(2, header);
	}

];


/**
 * HTML.H3  -- level 3 header.
 */
extern H3 = [class: Hx,

	new(header)
	{
		return this:^new(3, header);
	}

];


/**
 * HTML.H4  -- level 4 header.
 */
extern H4 = [class: Hx,

	new(header)
	{
		return this:^new(4, header);
	}

];


/**
 * HTML.H5  -- level 5 header.
 */
extern H5 = [class: Hx,

	new(header)
	{
		return this:^new(5, header);
	}

];


/**
 * HTML.H6  -- level 6 header.
 */
extern H6 = [class: Hx,

	new(header)
	{
		return this:^new(6, header);
	}

];


/**
 * HTML.Pre  --  preformatted text element
 */
extern Pre = [class: Element,

	new(text)
	{
		return this:^new("pre", text);
	}

];


/**
 * HTML.Anchor  --  make element body a hyperlink
 *
 * This a wrapper element that makes its body, including
 * any child elements, a hyperlink to the given URL.
 */
extern Anchor = [class: Element,

	new(url, text)
	{
		this = this:^new("a", text);
		if (url)
			this:attr("href", url);
		return this;
	}

	url(url)
	{
		return this:attr("href", url);
	}

];


/**
 * HTML.UList  --  unlabelled list element.
 *
 * The HTML.UList element presents any HTML.ListItem children
 * in a unlabelled list.
 */
extern UList = [class: Element,

	new()
	{
		return this:^new("ul");
	}

];


/**
 * HTML.OList  --  ordinal list element.
 *
 * The HTML.OList presents any HTML.ListItem child elements
 * within a labelled list.
 */
extern OList = [class: Element,

	new()
	{
		return this:^new("ol");
	}

];


/**
 * HTML.DList  --  ordinal list element.
 *
 * The HTML.OList presents any HTML.ListItem child elements
 * within a labelled list.
 */
extern DList = [class: Element,

	new()
	{
		return this:^new("dl");
	}

];

extern Dt = [class: NoEndTagElement,

	new(text)
	{
		return this:^new("dt", text);
	}
];

extern Dd = [class: NoEndTagElement,

	new(text)
	{
		return this:^new("dd", text);
	}

];


/**
 * HTML.DirList
 */
extern DirList = [class: Element,

	new()
	{
		return this:^new("dir");
	}

];


/**
 * HTML.Menu
 */
extern Menu = [class: Element,

	new()
	{
		return this:^new("menu");
	}

];



/**
 * HTML.ListItem  --  item within a list element.
 *
 * This is wrapper class that makes its body and
 * children an item within a list.
 */
extern ListItem = [class: Element,

	new(text)
	{
		return this:^new("li", text);
	}

];


/**
 * HTML.TableElement  --  internal base class for Table elements.
 *
 * This provides common attribute setting methods.
 */
static TableElement = [class: Element,

	bgcolor(color)
	{
		return this:attr("bgcolor", color);
	}

	width(w)
	{
		return this:attr("width", string(w));
	}

	height(h)
	{
		return this:attr("height", string(h));
	}

	align(where)
	{
		return this:attr("align", where);
	}

	valign(where)
	{
		return this:attr("valign", where);
	}

];


/**
 * HTML.Table  --  a table element.
 */
extern Table = [class: TableElement,

	new(summary)
	{
		auto summary = "";
		this = this:^new("table");
		this:attr("summary", summary);
		return this;
	}

	summary(txt)
	{
		return this:attr("summary", txt);
	}

	border(width)
	{
		return this:attr("border", string(width));
	}

	cellspacing(spacing)
	{
		return this:attr("cellspacing", string(spacing));
	}
	
	cellpadding(padding)
	{
		return this:attr("cellpadding", string(padding));
	}

	newrow()
	{
		r := TableRow:new();
		this:add(r);
		return r;
	}

	newhead(label)
	{
		h := TableHeader:new(label);
		this:add(h);
		return h;
	}

];


/**
 * HTML.TableRow  --  a row within a table.
 *
 *
 */
extern TableRow = [class: TableElement,

	new()
	{
		return this:^new("tr");
	}

	newcell(v)
	{
		c := TableCell:new(v);
		this:add(c);
		return c;
	}

	emptycell()
	{
		c := EmptyTableCell:new();
		this:add(c);
		return c;
	}

];


/**
 * HTML.TableCell  --  a cell within a table row.
 *
 *
 */
extern TableCell = [class: TableElement,

	new(text)
	{
		return this:^new("td", text);
	}

	colspan(n)
	{
		return this:attr("colspan", string(n));
	}

	rowspan(n)
	{
		return this:attr("rowspan", string(n));
	}
];


/**
 * HTML.EmptyTableCell  --  a cell containing a non-breaking space
 */
extern EmptyTableCell = [class: TableCell,

	new()
	{
		this = this:^new();
		this:add(NonBreakingSpace);
		return this;
	}

];

/**
 * HTML.TableHeader  --  a table heading cell.
 */
extern TableHeader = [class: TableElement,

	new(label)
	{
		return this:^new("th", label);
	}

	colspan(n)
	{
		return this:attr("colspan", string(n));
	}

];


/**
 * HTML.Form  --  an input form.
 *
 *
 */
extern Form = [class: Element,

	new(action, method)
	{
		auto method = "POST";
		this = this:^new("form");
		this:attr("action", action);
		this:attr("method", method);
		return this;
	}

	action(action)
	{
		return this:attr("action", action);
	}

	method(method)
	{
		return this:attr("method", method);
	}

	hidden_field(key, val)
	{
		return this:add(HTML.HiddenField:new(key, val));
	}

];


/**
 * HTML.InputElement  --  internal base class for input elements.
 *
 */
static InputElement = [class: NoEndTagElement,

	new(typ, nom, val)
	{
		this = this:^new("input");
		this:type(typ);
		this:name(nom);
		this:value(val);
		return this;
	}

	type(typ)
	{
		return this:attr("type", typ);
	}

	name(nom)
	{
		return this:attr("name", nom);
	}

	value(val)
	{
		if (val)
			this:attr("value", val);
		return this;
	}

];


/**
 * HTML.SubmitButton  --  form submission button element.
 *
 */
extern SubmitButton = [class: InputElement,

	new(val, nom)
	{
		auto nom = "submit";
		this = this:^new("submit", nom, val);
		return this;
	}

];


/**
 * HTML.ResetButton  --  form input reset button element.
 */
extern ResetButton = [class: InputElement,

	new(val, nom)
	{
		auto nom = "reset";
		this = this:^new("reset", nom, val);
		return this;
	}

];


/**
 * HTML.InputImage
 */
extern InputImage = [class: InputElement,

	new(nom, url)
	{
		this = this:^new("image", nom);
		return this:set_src(url);
	}

	set_src(url)
	{
		return this:attr("src", url);
	}

	align(a)
	{
		return this:attr("align", a);
	}

];



/**
 * HTML.TextField  --  a text field form element
 *
 */
extern TextField = [class: InputElement,

	new(name, val, size, maxlength)
	{
		auto val = "";
		this = this:^new("text", name, val);
		if (size)
			this:attr("size", string(size));
		if (maxlength)
			this:attr("maxlength", string(maxlength));
		return this;
	}

];


/**
 * HTML.PasswordField  --  a password field form element
 */
extern PasswordField = [class: InputElement,

	new(name, val, size, maxlength)
	{
		auto val = "";
		this = this:^new("password", name, val);
		if (size)
			this:attr("size", string(size));
		if (maxlength)
			this:attr("maxlength", string(maxlength));
		return this;
	}

];


/**
 * HTML.CheckedInputElement  --  an input element that supports "checking"
 */
static CheckedInputElement = [class: InputElement,

	new(type, name, val, checked)
	{
		this = this:^new(type, name, val);
		this.cie_checked := checked;
		return this;
	}

	checked(flag)
	{
		auto flag = true;
		cie_checked = flag;
		return this;
	}

	is_checked()
	{
		return cie_checked;
	}

	output_attr(file)
	{
		this:^output_attr(file);
		if (cie_checked)
			printf(file, " checked");
	}

];


/**
 * HTML.Checkbox  --  checkbox form element.
 */
extern Checkbox = [class: CheckedInputElement,

	new(name, checked, val)
	{
		return this:^new("checkbox", name, val, checked);
	}

];


/**
 * HTML.HiddenField  --  an invisible form element
 */
extern HiddenField = [class: InputElement,

	new(name, val)
	{
		auto val = "";
		return this:^new("hidden", name, val);
	}

];


/**
 * HTML.TextArea  --  multi-line text input field
 */
extern TextArea = [class: Element,

	new(name, text)
	{
		this = this:^new("textarea", text);
		this:attr("name", name);
		return this;
	}

	rows(n)
	{
		return this:attr("rows", string(n));
	}

	cols(n)
	{
		return this:attr("cols", string(n));
	}

];


/**
 * HTML.Radio  --  a member of radio button group
 */
extern Radio = [class: CheckedInputElement,

	new(name, text, val, checked)
	{
		return this:^new("radio", name, val, checked);
	}

];


/**
 * HTML.FileSelector  --  a file selector form element
 */
extern FileSelector = [class: InputElement,

	new(name, val)
	{
		return this:^new("file", name, val);
	}

];


/**
 * HTML.IsIndex  --  simple search field
 */
extern IsIndex = [class: NoEndTagElement,

	new(prompt)
	{
		this = this:^new("isindex");
		if (prompt)
			this:attr("prompt", prompt);
		return this;
	}

	prompt(str)
	{
		return this:attr("prompt", str);
	}

];


/**
 * HTML.SelectList  --  select list
 */
extern SelectList = [class: Element,

	new(name, size, mult)
	{
		this = this:^new("select");
		this:attr("name", name);
		if (size)
			this:size(size);
		this.s_multiple := mult;
		return this;
	}

	output_attr(file)
	{
		if (s_multiple)
			printf(file, " multiple");
		this:^output_attr(file);
	}

	multiple(flag)
	{
		auto flag = true;
		s_multiple = flag;
		return this;
	}

	size(n)
	{
		return this:attr("size", string(n));
	}

];


/**
 * HTML.Div  --  a division
 */
extern Div = [class: Element,

	new(text)
	{
		return this:^new("div", text);
	}

	align(a)
	{
		return this:attr("align", a);
	}

];


/**
 * HTML.SelectOption  --  an option within a select list
 */
extern SelectOption = [class: Element,

	new(val, text)
	{
		this = this:^new("option", text);
		this.o_selected := false;
		return this:value(val);
	}

	value(val)
	{
		return this:attr("value", val);
	}

	selected(flag)
	{
		auto flag = true;
		o_selected = flag;
		return this;
	}

	output_attr(file)
	{
		if (o_selected)
			printf(file, " selected");
		this:^output_attr(file);
	}

];


/**
 * HTML.Entity  --  class to represent embedded HTML "entities"
 *
 * An entity is a named character glyph with a specific representation
 * within HTML  --  "&" <name> ";".  This class implements the element
 * output protocol to allow entities to be used as child elements.
 */
extern Entity = [class

	new(what)
	{
		this = this:^new();
		this.e_what := what;
		return this;
	}

	output(file)
	{
		printf(file, "&%s;", e_what);
	}

];


/**
 * Commonly used entities.
 */
extern Ampersand	= Entity:new("amp");
extern GreaterThan	= Entity:new("gt");
extern LessThan		= Entity:new("lt");
extern NonBreakingSpace	= Entity:new("nbsp");
extern CopyrightSymbol	= Entity:new("copy");
extern TrademarkSymbol	= Entity:new("trade");
extern RegisteredTrademarkSymbol = Entity:new("reg");


/*
 * $Log: ici3HTML.ici,v $
 * Revision 1.10  2002/05/23 00:29:26  atrn
 * Added EmptyTableCell for simpler addition of blank cells
 *
 * Revision 1.9  2002/03/13 04:40:28  atrn
 * Add trademark entities
 *
 * Revision 1.8  2002/01/27 20:54:18  atrn
 * Added support for other types of lists, a method to get all the query
 * string parameters, add a character encoding spec. to the document
 * header, a method for creating hidden fields in tables, allow submit
 * and reset button values to be set and remove old ImageInput class.
 *
 * Revision 1.7  2002/01/26 07:18:20  atrn
 * Added CGI support, turned on by default but controllable at Page:new()
 * time.  CGI support includes automatic output of CGI headers when a
 * page element is output and support for CGI query strings via the
 * page:param() method.  Added HTML.Div() class for divisions.
 *
 * Revision 1.6  2002/01/26 05:54:45  atrn
 * Delay calling of functions, or methods, added as children until the
 * containing element is output.  Added support for "image" input
 * elements, <INPUT TYPE="IMAGE"...>.
 *
 * Revision 1.5  2002/01/25 23:27:04  atrn
 * Added bgcolor() and text_colors() methods to HTML.Page to complement
 * the existing page:colors() method.  Bgcolor() is there to match other
 * elements and text_colors() to complement it.  Colors() still exists
 * to set them all in one shot.
 *
 * Revision 1.4  2002/01/22 05:33:52  atrn
 * Added a value to CheckedInputElement and added this to Checkbox.
 *
 * Revision 1.3  2002/01/21 03:49:29  atrn
 * Removed the HTML.Text class and implemented the functionality by
 * allowing strings as element children.  These are encoded and output
 * as per other user-supplied text.
 *
 * Revision 1.2  2002/01/21 03:42:57  atrn
 * Added the HTML.Text class for embedding textual content as a child of
 * an element.  Unlike HTML.Markup elements this text is HTML encoded.
 *
 * Revision 1.1  2002/01/20 01:57:24  atrn
 * Added class-based HTML page generation module.
 *
 */

/*
 * For x?emacs...
 * Local Variables:
 * mode:c
 * c-basic-offset:8
 * tab-width:8
 * End:
 */
