/*
 * This script generates a Makefile in each of the module directories
 * on the list below for a UNIX-like system. Each Makefile is tailored to
 * build the modules on, and for, the flavour of system this script is
 * run on. The known flavours are listed below.
 *
 * The Makefiles it generates are made by the following process:
 *
 * 1) If the sub-dir contains a Makefile.flavour, where flavour is
 *    the current system, that file is used as a basis.
 *    Otherwise, if the sub-dir contains a Makefile.generic, that
 *    is used as a basis.
 *    Otherwise, the Makefile.generic from this top level directory is
 *    used as a basis.
 *
 * 2) The makefile being used as a basis is copied to Makefile in the
 *    module directory with certain $(...) variables textually replaced
 *    by this script from values in the tables below.
 *
 * Ideally, a module will not have any Makefiles, and the generic one
 * will be sufficient. However, if there are special build requirements,
 * for a particular module, the Makefile.generic can be copied into the
 * sub-dir and tailored. If, for some systems, even this is not enough,
 * the Makefile that this script generates can be copied to Makefile.flavour
 * and specific arrangements made for the particular module on the
 * particular system.
 *
 * This script only uses core ICI features (because, of course, you
 * might not have any other modules built yet).
 *
 * Anyone adding modules or systems is invited to add to the tables
 * below (if you think you know what you are doing).
 *
 * The most-generic Makefile (the one in this directory) assumes that
 * *.c in module dir should be built into a library.
 *
 */
 
/*
 * The modules that this script will process, and the system
 * flavous for which it will do it.
 */
static modules = [struct

    sys     = [set "bsd", "linux", "osx", "sol2"          ],
    net     = [set "bsd", "linux", "osx", "sol2", "cygwin"],
    xml     = [set "bsd", "linux",        "sol2"          ],
];

/*
 * The substitutions that are performed in copying a Makefile.generic to
 * a particular module for a paricular flavour. If an entry is a function,
 * it is called to get a string. If an entry is a struct, it is indexed
 * by the flavour to find a value. If the flavour is not found, the default
 * entry is used. If an entry is a string, it is used directly.
 */
static subs = [struct

    /*
     * ICIV: ici4 or whatever version number we are up to.
     */
    ICIV = "ici4",
    
    /*
     * ICISDK: The location of the ICISDK. In particular, the location
     * of ici.h for this system. This could be the directory where ICI
     * was recently built. (If relative, relative to the module dir.)
     */
    ICISDK = "../../ici",
    //ICISDK = "/usr/local/lib/ici4",

    /*
     * MOD: the name of the module (like sys, or net).
     */
    MOD = [func(){return module;}],
    
    /*
     * ICIOBJS: *.c in the module dir with all the .c changed to .o.
     */
    ICIOBJS = [func()
        {
            cs := dir(module, #\.c$#);
            r := strbuf();
            forall (c in cs)
                strcat(r, c ~~ #^(.*)\.c$#, ".o", " ");
            return r;
        }],
        
    /*
     * ICISRCS: *.c in the module dir.
     */
    ICISRCS = [func()
        {
            cs := dir(module, #\.c$#);
            r := strbuf();
            forall (c in cs)
                strcat(r, c, " ");
            return r;
        }],
     
    /*
     * PIC: is the option to the C compiler to make it produce
     * position independent code suitable for a shared or dynamicly
     * loading library of the sort ICI needs on this system.
     */
    PIC =
        [struct
            osx = "-dynamic -fno-common",
            cygwin = "",
            default = "-fpic"
        ],
    
    /*
     * SOSUFFIX: The suffix the shared, dynamic link, dynamic load,
     * or whatever library should have to be suitable for ICI.
     */
    SOSUFFIX = [struct osx = "dylib", default = "so"],
    
    /*
     * $(OPTIM) The argument to the C compiler to turn on optimisation.
     */
    OPTIM = [struct default = "-g -O2 -DNDEBUG"],
    //OPTIM = [struct default = "-g"],
    
    /*
     * ICICFLAGS C compiler options in addition to the others already
     * mentioned here.
     */
    ICICFLAGS =
        [struct
            bsd = "-DBSD_4",
            sol2 = "-DSUNOS5",
            cygwin = "-ansi",
            default = ""
        ],

    /*
     * ICILDFLAGS Linker options in addition to the others already
     * mentioned here.
     */
    ICILDFLAGS =
        [struct
            osx = "-flat_namespace -bundle -undefined suppress "
                "-install_name /usr/local/lib/ici4/$(LIB)",
	    sol2 = "-G",
            cygwin = "-dll",
            default = "-shared",
        ],
    
    /*
     * LIBS Any other libs that should be linked in.
     */
    LIBS = "",
    
    OTHERDEFS =
        [struct
            sol2 = "CC\t= gcc -pipe",
            cygwin = "CC\t= gcc",
            default = "",
        ],

    OTHERRULES = "",
    
    MAKEIN = [func(){return makein;}],
    MAKEOUT = [func(){return makeout;}],
    FLAVOUR = [func(){return flavour;}],
];
 
/*
 * The following struct maps the system uname to a particular ici "flavour".
 * Entries can be either strings or functions. If they are functions it is
 * called to return a string giving the flavour. Every system must have an
 * entry otherwise it is declared "unsupported".
 */
static flavours = [struct

    Darwin      = "osx",
    FreeBSD     = "bsd",
    NetBSD      = "bsd",
    Linux       = "linux",
    ("CYGWIN_NT-5.0") = "cygwin",
    /*
     * SunOS 1.x and 2.x have the same uname but are different beasts
     */
    SunOS       =
        [func()
        {
            try
                {close(fopen("/vmunix")); return "sunos";}
            onerror
                return "sol2";
        }],
    Win32       = "w32",
];

/*--------------------End of tables, start of code.----------------------*/

/*
 * Get uname and find ICI style system flavour.
 */
static flavour;
if (argv[1] != NULL)
{
    uname = "command line";
    flavour = argv[1];
}
else
{
    uname := getline(p := popen("uname"));
    close(p);
    if (!(flavour = flavours[uname]))
        fail(sprintf("don't know what flavour of unix \"%s\" is", uname));

    if (typeof(flavour) == "func")
        flavour = flavour();
}
printf("Uname \"%s\", therefor flavour \"%s\".\n", uname, flavour);

static module;

/*
 * Build a regular expression from the keys of the subs struct.
 */
re = strbuf("\\$\\((");
forall (v, k in subs)
    strcat(re, k, "|");
strcat(re, nels(re) - 1, ")\\)");
re = regexp(re);

/*
 * Forall the modules, generate the Makefiles we can.
 */
static makein, makeout;
forall (can_do_flavs, module in modules)
{
    if (!can_do_flavs[flavour])
        continue;
    /*
     * Find and read a Makefile to use as a basis.
     */
    try
        f = fopen(makein = sprintf("%s/Makefile.%s", module, flavour));
    onerror try
        f = fopen(makein = sprintf("%s/Makefile.generic", module));
    onerror
        f = fopen(makein = "Makefile.generic");
    f = getfile(f);
    makeout = sprintf("%s/Makefile", module);
    
    /*
     * Break it into bits to be replaced, and bits not to be replaced,
     * using that regular expression we built.
     */
    f = smash(f, re, "\\0", "\\1", 1);
    /*
     * Perform substitutions on the odd numbered entries.
     */
    forall (s, i in f)
    {
        if ((i & 1) == 0)
            continue;
        s = subs[s];
        if (typeof(s) == "string")
            ;
        else if (typeof(s) == "func")
            s = s();
        else if (s[flavour] != NULL)
            s = s[flavour];
        else
            s = s.default;
        f[i] = s;
    }
    put(implode(f), (fo := fopen(makeout, "w")));
    close(fo);
    printf("%s -> %s\n", makein, makeout);
}
