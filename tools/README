This directory contains some tools that make writing modules a little
easier. To start with there's a makefile that can be copied and
customised for a module. For most things it needs only the name of the 
module, its object files and any special switches to the compiler to
be specified. Everything else is taken care of. The most important
things are defined as variables at the start of the file which makes
it easy to customise.

This makefile uses some ICI programs to automate some of the tasks of
module writing. Two things that are particularly tiresome are defining 
ICI string objects for commonly used strings and defining the table of 
function objects the module exports. The mk-ici-dot-h.ici script
generates a header file, ici.h, that is supposed to be included by
every source file in the module. The ici.h header defines a number of
macros to make the two tasks easier.

Firstly for defining functions that are exported by the module the
FUNC() macro is used. This takes a single parameter, the name of the
function. It should be followed by the function's body. E.g.,

	FUNC(getpid)
	{
	    return int_ret(getpid());
	}

The mk-cfuncs.ici program takes advantage of this function. It scans
source files for lines that start with "FUNC" and generates a file
that has external declarations for the functions and a cfunc table. In 
addition this file, cfuncs.c, defines the module's initialisation
function that uses the cfunc table to populate a struct object used to 
represent the module.

The FUNC() macro must be used to define functions that are exported by 
the module. If it is not used the function will not be detected and
not placed in the cfuncs table. Also the macro must appear at the
beginning of the line. This is not considered a major limitation.

The second thing ici.h does for you is define a method for defining
string objects that are required by the module. A set of macros is
provided in ici.h to simplify much of this task. The first macro is
NEED_STRING(). This is used at the C module scope to declare an extern
reference to a string object. This declares that the module requires a 
particular string. The macro takes a single parameter, the string that 
is required. Strings used with the string macros must be valid C
identifiers, i.e., they may contain letters, numbers and underscores.

To refer to a string object the STRING() macro is used. This takes a
single parameter, a string as given to NEED_STRING, and results in a
reference to an ICI string object. In functions that use STRING() the
NEED_STRINGS() macro should be called first. This ensures the string
objects exist. It takes a single parameter, the operand to the
"return" embedded within the macro invoked when string generation fails.

It sounds complicated but is really easy to use in practice. This
makes it clearer.

	/*
	 * In this example we have a type that may be indexed with
	 * a number of different strings. To avoid generating the
	 * strings all the time we use the macros in ici.h to help
	 * use them efficiently.
	 */

	NEED_STRING(type);
	NEED_STRING(title);

	object_t *fetch_mytype(object_t *self, object_t *key)
	{
	    NEED_STRINGS(NULL);

	    if (key == STRING(type))
		...  return something for key "type"

	    if (key == STRING(title))
		...  and for key "title"
	}


The use of all these macros makes it easy to generate code that makes
the module private. The macros prefix all names with "ici_" and the
module's name making the possibility of name clashes minimal. The
Makefile defines a name which is passed to the various helper programs 
to use as the module name.
